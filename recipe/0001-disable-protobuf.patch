diff --git a/CMakeLists.txt b/CMakeLists.txt
index 66931b0..e44a113 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -9,7 +9,6 @@ if(MSVC)
   endif()
 endif()
 
-option(ENABLE_PROTOBUF "Enable Protobuf" OFF)
 option(TEST_COVERAGE "C++ test coverage" OFF)
 option(USE_OPENMP "Use OpenMP" ON)
 option(BUILD_CPP_TEST "Build C++ tests" OFF)
diff --git a/cmake/ExternalLibs.cmake b/cmake/ExternalLibs.cmake
index 86a63f2..b190f78 100644
--- a/cmake/ExternalLibs.cmake
+++ b/cmake/ExternalLibs.cmake
@@ -15,29 +15,6 @@ FetchContent_Declare(
 FetchContent_MakeAvailable(fmtlib)
 set_target_properties(fmt PROPERTIES EXCLUDE_FROM_ALL TRUE)
 
-# Protobuf
-if(ENABLE_PROTOBUF)
-  set(Protobuf_USE_STATIC_LIBS ON)
-  find_package(Protobuf)
-  if(NOT Protobuf_FOUND)
-    message(STATUS "Did not found Protobuf in the system root. Fetching Protobuf now...")
-    set(protobuf_BUILD_TESTS OFF CACHE BOOL "Build tests for protobuf" FORCE)
-    set(protobuf_BUILD_SHARED_LIBS OFF CACHE BOOL "enable shared libs for protobuf" FORCE)
-    FetchContent_Populate(protobuf
-      GIT_REPOSITORY  https://github.com/protocolbuffers/protobuf
-      GIT_TAG         v3.12.3
-      SOURCE_SUBDIR   cmake
-    )
-    add_subdirectory(${protobuf_SOURCE_DIR}/cmake ${protobuf_BINARY_DIR})
-    set(Protobuf_PROTOC_EXECUTABLE protobuf::protoc)
-    set(Protobuf_INCLUDE_DIRS ${protobuf_SOURCE_DIR}/src)
-    set(Protobuf_LIBRARIES protobuf::libprotobuf)
-    set_target_properties(libprotobuf PROPERTIES POSITION_INDEPENDENT_CODE ON)
-  endif()
-else()
-  set(Protobuf_LIBRARIES "")
-endif()
-
 # Google C++ tests
 if(BUILD_CPP_TEST)
   find_package(GTest)
diff --git a/cmake/TreeliteConfig.cmake.in b/cmake/TreeliteConfig.cmake.in
index 460c72c..bc5de10 100644
--- a/cmake/TreeliteConfig.cmake.in
+++ b/cmake/TreeliteConfig.cmake.in
@@ -3,13 +3,9 @@
 include(CMakeFindDependencyMacro)
 
 set(USE_OPENMP @USE_OPENMP@)
-set(ENABLE_PROTOBUF @ENABLE_PROTOBUF@)
 if(USE_OPENMP)
   find_dependency(OpenMP)
 endif()
-if(ENABLE_PROTOBUF)
-  find_dependency(Protobuf)
-endif()
 if(NOT TARGET treelite::treelite)
   include(${CMAKE_CURRENT_LIST_DIR}/TreeliteTargets.cmake)
 endif()
diff --git a/cmake/Utils.cmake b/cmake/Utils.cmake
index b29bd55..195e05e 100644
--- a/cmake/Utils.cmake
+++ b/cmake/Utils.cmake
@@ -40,128 +40,3 @@ function(set_default_configuration_release)
     set(CMAKE_BUILD_TYPE Release CACHE STRING "Choose the type of build." FORCE )
   endif()
 endfunction(set_default_configuration_release)
-
-#=============================================================================
-# Copyright 2009 Kitware, Inc.
-# Copyright 2009-2011 Philip Lowman <philip@yhbt.com>
-# Copyright 2008 Esben Mose Hansen, Ange Optimization ApS
-#
-# Distributed under the OSI-approved BSD License (the "License");
-# see accompanying file Copyright.txt for details.
-#
-# This software is distributed WITHOUT ANY WARRANTY; without even the
-# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-# See the License for more information.
-#=============================================================================
-# (To distribute this file outside of CMake, substitute the full
-#  License text for the above reference.)
-function(PROTOBUF_GENERATE_CPP SRCS HDRS)
-  if(NOT ARGN)
-    message(SEND_ERROR "Error: PROTOBUF_GENERATE_CPP() called without any proto files")
-    return()
-  endif()
-
-  # Create an include path for each file specified
-  foreach(FIL ${ARGN})
-    get_filename_component(ABS_FIL ${FIL} ABSOLUTE)
-    get_filename_component(ABS_PATH ${ABS_FIL} PATH)
-    list(FIND _protobuf_include_path ${ABS_PATH} _contains_already)
-    if(${_contains_already} EQUAL -1)
-      list(APPEND _protobuf_include_path -I ${ABS_PATH})
-    endif()
-  endforeach()
-
-  if(DEFINED Protobuf_IMPORT_DIRS)
-    foreach(DIR ${Protobuf_IMPORT_DIRS})
-      get_filename_component(ABS_PATH ${DIR} ABSOLUTE)
-      list(FIND _protobuf_include_path ${ABS_PATH} _contains_already)
-      if(${_contains_already} EQUAL -1)
-        list(APPEND _protobuf_include_path -I ${ABS_PATH})
-      endif()
-    endforeach()
-  endif()
-
-  set(PROTOC_DEPENDENCY ${Protobuf_PROTOC_EXECUTABLE})
-
-  set(${SRCS})
-  set(${HDRS})
-  foreach(FIL ${ARGN})
-    get_filename_component(ABS_FIL ${FIL} ABSOLUTE)
-    get_filename_component(FIL_WE ${FIL} NAME_WE)
-
-    list(APPEND ${SRCS} "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.cc")
-    list(APPEND ${HDRS} "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.h")
-
-    add_custom_command(
-      OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.cc"
-           "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.h"
-      COMMAND ${Protobuf_PROTOC_EXECUTABLE}
-      ARGS --cpp_out ${CMAKE_CURRENT_BINARY_DIR} ${_protobuf_include_path} ${ABS_FIL}
-      DEPENDS ${ABS_FIL} ${PROTOC_DEPENDENCY}
-      COMMENT "Running C++ protocol buffer compiler on ${FIL}"
-      VERBATIM
-    )
-  endforeach()
-
-  set_source_files_properties(${${SRCS}} ${${HDRS}} PROPERTIES GENERATED TRUE)
-  set(${SRCS} ${${SRCS}} PARENT_SCOPE)
-  set(${HDRS} ${${HDRS}} PARENT_SCOPE)
-endfunction()
-
-function(PROTOBUF_GENERATE_JAVA TARGET_NAME PROTO_FILE)
-  get_filename_component(ABS_FIL ${PROTO_FILE} ABSOLUTE)
-  get_filename_component(ABS_PATH ${ABS_FIL} PATH)
-  get_filename_component(FIL_WE ${PROTO_FILE} NAME_WE)
-  list(FIND _protobuf_include_path ${ABS_PATH} _contains_already)
-  if(${_contains_already} EQUAL -1)
-    list(APPEND _protobuf_include_path -I ${ABS_PATH})
-  endif()
-
-  if(DEFINED Protobuf_IMPORT_DIRS)
-    foreach(DIR ${Protobuf_IMPORT_DIRS})
-      get_filename_component(ABS_PATH ${DIR} ABSOLUTE)
-      list(FIND _protobuf_include_path ${ABS_PATH} _contains_already)
-      if(${_contains_already} EQUAL -1)
-        list(APPEND _protobuf_include_path -I ${ABS_PATH})
-      endif()
-    endforeach()
-  endif()
-
-  set(PROTOC_DEPENDENCY ${Protobuf_PROTOC_EXECUTABLE})
-
-  add_custom_target(${TARGET_NAME} ALL
-    ${Protobuf_PROTOC_EXECUTABLE} --java_out ${CMAKE_CURRENT_BINARY_DIR} ${_protobuf_include_path} ${ABS_FIL}
-    DEPENDS ${ABS_FIL} ${PROTOC_DEPENDENCY}
-    COMMENT "Running Java protocol buffer compiler on ${PROTO_FILE}"
-    VERBATIM
-  )
-endfunction()
-
-function(PROTOBUF_GENERATE_PYTHON TARGET_NAME PROTO_FILE)
-  get_filename_component(ABS_FIL ${PROTO_FILE} ABSOLUTE)
-  get_filename_component(ABS_PATH ${ABS_FIL} PATH)
-  get_filename_component(FIL_WE ${PROTO_FILE} NAME_WE)
-  list(FIND _protobuf_include_path ${ABS_PATH} _contains_already)
-  if(${_contains_already} EQUAL -1)
-    list(APPEND _protobuf_include_path -I ${ABS_PATH})
-  endif()
-
-  if(DEFINED Protobuf_IMPORT_DIRS)
-    foreach(DIR ${Protobuf_IMPORT_DIRS})
-      get_filename_component(ABS_PATH ${DIR} ABSOLUTE)
-      list(FIND _protobuf_include_path ${ABS_PATH} _contains_already)
-      if(${_contains_already} EQUAL -1)
-        list(APPEND _protobuf_include_path -I ${ABS_PATH})
-      endif()
-    endforeach()
-  endif()
-
-  set(PROTOC_DEPENDENCY ${Protobuf_PROTOC_EXECUTABLE})
-
-  add_custom_target(${TARGET_NAME} ALL
-    ${Protobuf_PROTOC_EXECUTABLE} --python_out ${CMAKE_CURRENT_BINARY_DIR} ${_protobuf_include_path} ${ABS_FIL}
-    DEPENDS ${ABS_FIL} ${PROTOC_DEPENDENCY}
-    COMMENT "Running Python protocol buffer compiler on ${PROTO_FILE}"
-    VERBATIM
-  )
-endfunction()
diff --git a/include/treelite/c_api.h b/include/treelite/c_api.h
index 544f962..8f0f528 100644
--- a/include/treelite/c_api.h
+++ b/include/treelite/c_api.h
@@ -250,26 +250,6 @@ TREELITE_DLL int TreeliteLoadXGBoostModel(const char* filename,
 TREELITE_DLL int TreeliteLoadXGBoostModelFromMemoryBuffer(const void* buf,
                                                           size_t len,
                                                           ModelHandle* out);
-/*!
- * \brief load a model in Protocol Buffers format. Protocol Buffers
- *        (google/protobuf) is a language- and platform-neutral mechanism for
- *        serializing structured data. See tree.proto for format spec.
- * \param filename name of model file
- * \param out loaded model
- * \return 0 for success, -1 for failure
- */
-TREELITE_DLL int TreeliteLoadProtobufModel(const char* filename,
-                                           ModelHandle* out);
-/*!
- * \brief export a model in Protocol Buffers format. Protocol Buffers
- *        (google/protobuf) is a language- and platform-neutral mechanism for
- *        serializing structured data. See src/tree.proto for format spec.
- * \param filename name of model file
- * \param model model to export
- * \return 0 for success, -1 for failure
- */
-TREELITE_DLL int TreeliteExportProtobufModel(const char* filename,
-                                             ModelHandle model);
 /*!
  * \brief Query the number of trees in the model
  * \param handle model to query
diff --git a/include/treelite/frontend.h b/include/treelite/frontend.h
index 3c6acd6..67272ce 100644
--- a/include/treelite/frontend.h
+++ b/include/treelite/frontend.h
@@ -42,22 +42,6 @@ void LoadXGBoostModel(const char* filename, Model* out);
  * \param out reference to loaded model
  */
 void LoadXGBoostModel(const void* buf, size_t len, Model* out);
-/*!
- * \brief load a model in Protocol Buffers format. Protocol Buffers
- *        (google/protobuf) is a language- and platform-neutral mechanism for
- *        serializing structured data. See tree.proto for format spec.
- * \param filename name of model file
- * \param out reference to loaded model
- */
-void LoadProtobufModel(const char* filename, Model* out);
-/*!
- * \brief export a model in Protocol Buffers format. Protocol Buffers
- *        (google/protobuf) is a language- and platform-neutral mechanism for
- *        serializing structured data. See src/tree.proto for format spec.
- * \param filename name of model file
- * \param model model to export
- */
-void ExportProtobufModel(const char* filename, const Model& model);
 
 //--------------------------------------------------------------------------
 // model builder interface: build trees incrementally
diff --git a/python/treelite/frontend.py b/python/treelite/frontend.py
index 5c7c01f..9dbc324 100644
--- a/python/treelite/frontend.py
+++ b/python/treelite/frontend.py
@@ -266,25 +266,6 @@ class Model():
             c_str(dirpath)))
         _check_call(_LIB.TreeliteCompilerFree(compiler_handle))
 
-    def export_protobuf(self, filename):
-        """
-        Export a tree ensemble model as a Protocol Buffers format. Protocol Buffers
-        (google/protobuf) is a language- and platform-neutral mechanism for
-        serializing structured data. See src/tree.proto for format spec.
-
-        Parameters
-        ----------
-        filename : :py:class:`str <python:str>`
-            path to save Protocol Buffers output
-
-        Example
-        -------
-        .. code-block:: python
-
-           model.export_protobuf('./my.buffer')
-        """
-        _check_call(_LIB.TreeliteExportProtobufModel(c_str(filename), self.handle))
-
     @staticmethod
     def _set_compiler_param(compiler_handle, params, value=None):
         """
@@ -360,7 +341,7 @@ class Model():
         filename : :py:class:`str <python:str>`
             path to model file
         model_format : :py:class:`str <python:str>`
-            model file format. Must be one or 'xgboost', 'lightgbm', 'protobuf'
+            model file format. Must be one or 'xgboost', 'lightgbm'
 
         Returns
         -------
@@ -384,12 +365,9 @@ class Model():
         elif model_format == 'xgboost':
             _check_call(_LIB.TreeliteLoadXGBoostModel(c_str(filename),
                                                       ctypes.byref(handle)))
-        elif model_format == 'protobuf':
-            _check_call(_LIB.TreeliteLoadProtobufModel(c_str(filename),
-                                                       ctypes.byref(handle)))
         else:
             raise ValueError('Unknown model_format: must be one of ' \
-                             + '{lightgbm, xgboost, protobuf}')
+                             + '{lightgbm, xgboost}')
         return Model(handle)
 
 
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index c92c7d1..ea2e77b 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -53,19 +53,6 @@ set_target_properties(objtreelite objtreelite_runtime objtreelite_common
   CXX_STANDARD 11
   CXX_STANDARD_REQUIRED ON)
 
-# Use Protobuf optionally
-if(ENABLE_PROTOBUF)
-  target_include_directories(objtreelite PRIVATE ${Protobuf_INCLUDE_DIRS} ${CMAKE_CURRENT_BINARY_DIR})
-  target_compile_definitions(objtreelite PRIVATE -DTREELITE_PROTOBUF_SUPPORT)
-  target_link_libraries(objtreelite PRIVATE ${Protobuf_LIBRARIES})
-  PROTOBUF_GENERATE_CPP(TREE_PROTO_SRCS TREE_PROTO_HDRS tree.proto)
-  PROTOBUF_GENERATE_JAVA(tree_proto_java tree.proto)
-  PROTOBUF_GENERATE_PYTHON(tree_proto_python tree.proto)
-else()
-  set(TREE_PROTO_SRCS "")
-  set(TREE_PROTO_HDRS "")
-endif()
-
 target_sources(objtreelite
     PRIVATE
     c_api/c_api.cc
@@ -96,14 +83,11 @@ target_sources(objtreelite
     frontend/builder.cc
     frontend/lightgbm.cc
     frontend/xgboost.cc
-    frontend/protobuf.cc
     annotator.cc
     data.cc
     filesystem.cc
     optable.cc
     reference_serializer.cc
-    ${TREE_PROTO_SRCS}
-    ${TREE_PROTO_HDRS}
     ${PROJECT_SOURCE_DIR}/include/treelite/annotator.h
     ${PROJECT_SOURCE_DIR}/include/treelite/base.h
     ${PROJECT_SOURCE_DIR}/include/treelite/c_api.h
diff --git a/src/c_api/c_api.cc b/src/c_api/c_api.cc
index aa72593..1850ef2 100644
--- a/src/c_api/c_api.cc
+++ b/src/c_api/c_api.cc
@@ -334,23 +334,6 @@ int TreeliteLoadXGBoostModelFromMemoryBuffer(const void* buf, size_t len,
   API_END();
 }
 
-int TreeliteLoadProtobufModel(const char* filename,
-                              ModelHandle* out) {
-  API_BEGIN();
-  std::unique_ptr<Model> model{new Model()};
-  frontend::LoadProtobufModel(filename, model.get());
-  *out = static_cast<ModelHandle>(model.release());
-  API_END();
-}
-
-int TreeliteExportProtobufModel(const char* filename,
-                                ModelHandle model) {
-  API_BEGIN();
-  auto model_ = static_cast<Model*>(model);
-  frontend::ExportProtobufModel(filename, *model_);
-  API_END();
-}
-
 int TreeliteFreeModel(ModelHandle handle) {
   API_BEGIN();
   delete static_cast<Model*>(handle);
diff --git a/src/compiler/ast/ast.h b/src/compiler/ast/ast.h
index 7017f8c..6139a63 100644
--- a/src/compiler/ast/ast.h
+++ b/src/compiler/ast/ast.h
@@ -15,11 +15,6 @@
 #include <vector>
 #include <utility>
 
-// forward declaration
-namespace treelite_ast_protobuf {
-class ASTNode;
-}  // namespace treelite_ast_protobuf
-
 namespace treelite {
 namespace compiler {
 
diff --git a/src/frontend/protobuf.cc b/src/frontend/protobuf.cc
deleted file mode 100644
index 3185fb9..0000000
--- a/src/frontend/protobuf.cc
+++ /dev/null
@@ -1,351 +0,0 @@
-/*!
- * Copyright (c) 2017-2020 by Contributors
- * \file protobuf.cc
- * \brief Frontend for Protobuf model
- * \author Hyunsu Cho
- */
-
-#include <dmlc/logging.h>
-#include <dmlc/registry.h>
-#include <dmlc/io.h>
-#include <treelite/tree.h>
-#include <queue>
-
-#ifdef TREELITE_PROTOBUF_SUPPORT
-
-#include "tree.pb.h"
-
-namespace {
-
-enum class NodeType : int8_t {
-  kLeaf, kLeafVector, kNumericalSplit, kCategoricalSplit
-};
-
-inline NodeType GetNodeType(const treelite_protobuf::Node& node) {
-  if (node.has_left_child()) {  // node is non-leaf
-    CHECK(node.has_right_child());
-    CHECK(node.has_default_left());
-    CHECK(node.has_split_index());
-    CHECK(node.has_split_type());
-    CHECK(!node.has_leaf_value());
-    CHECK_EQ(node.leaf_vector_size(), 0);
-    const auto split_type = node.split_type();
-    if (split_type == treelite_protobuf::Node_SplitFeatureType_NUMERICAL) {
-      // numerical split
-      CHECK(node.has_op());
-      CHECK(node.has_threshold());
-      CHECK_EQ(node.left_categories_size(), 0);
-      return NodeType::kNumericalSplit;
-    } else {  // categorical split
-      CHECK(!node.has_op());
-      CHECK(!node.has_threshold());
-      CHECK(node.has_missing_category_to_zero());
-      return NodeType::kCategoricalSplit;
-    }
-  } else {  // node is leaf
-    CHECK(!node.has_right_child());
-    CHECK(!node.has_default_left());
-    CHECK(!node.has_split_index());
-    CHECK(!node.has_split_type());
-    CHECK(!node.has_op());
-    CHECK(!node.has_threshold());
-    CHECK(!node.has_gain());
-    CHECK(!node.has_missing_category_to_zero());
-    CHECK_EQ(node.left_categories_size(), 0);
-    if (node.has_leaf_value()) {
-      CHECK_EQ(node.leaf_vector_size(), 0);
-      return NodeType::kLeaf;
-    } else {
-      CHECK_GT(node.leaf_vector_size(), 0);
-      return NodeType::kLeafVector;
-    }
-  }
-}
-
-}  // anonymous namespace
-
-namespace treelite {
-namespace frontend {
-
-DMLC_REGISTRY_FILE_TAG(protobuf);
-
-void LoadProtobufModel(const char* filename, Model* out) {
-  GOOGLE_PROTOBUF_VERIFY_VERSION;
-
-  std::unique_ptr<dmlc::Stream> fi(dmlc::Stream::Create(filename, "r"));
-  dmlc::istream is(fi.get());
-  treelite_protobuf::Model protomodel;
-  CHECK(protomodel.ParseFromIstream(&is)) << "Ill-formed Protocol Buffers file";
-
-  Model model;
-  CHECK(protomodel.has_num_feature()) << "num_feature must exist";
-  const auto num_feature = protomodel.num_feature();
-  CHECK_LT(num_feature, std::numeric_limits<int>::max())
-    << "num_feature too big";
-  CHECK_GT(num_feature, 0) << "num_feature must be positive";
-  model.num_feature = static_cast<int>(protomodel.num_feature());
-
-  CHECK(protomodel.has_num_output_group()) << "num_output_group must exist";
-  const auto num_output_group = protomodel.num_output_group();
-  CHECK_LT(num_output_group, std::numeric_limits<int>::max())
-    << "num_output_group too big";
-  CHECK_GT(num_output_group, 0) << "num_output_group must be positive";
-  model.num_output_group = static_cast<int>(protomodel.num_output_group());
-
-  CHECK(protomodel.has_random_forest_flag())
-    << "random_forest_flag must exist";
-  model.random_forest_flag = protomodel.random_forest_flag();
-
-  // extra parameters field
-  const auto& ep = protomodel.extra_params();
-  std::vector<std::pair<std::string, std::string>> cfg;
-  std::copy(ep.begin(), ep.end(), std::back_inserter(cfg));
-  InitParamAndCheck(&model.param, cfg);
-
-  // flag to check consistent use of leaf vector
-  // 0: no leaf should use leaf vector
-  // 1: every leaf should use leaf vector
-  // -1: indeterminate
-  int8_t flag_leaf_vector = -1;
-
-  const int ntree = protomodel.trees_size();
-  for (int i = 0; i < ntree; ++i) {
-    model.trees.emplace_back();
-    Tree& tree = model.trees.back();
-    tree.Init();
-
-    CHECK(protomodel.trees(i).has_head());
-    // assign node ID's so that a breadth-wise traversal would yield
-    // the monotonic sequence 0, 1, 2, ...
-    std::queue<std::pair<const treelite_protobuf::Node&, int>> Q;
-      // (proto node, ID)
-    Q.push({protomodel.trees(i).head(), 0});
-    while (!Q.empty()) {
-      auto elem = Q.front(); Q.pop();
-      const treelite_protobuf::Node& node = elem.first;
-      int nid = elem.second;
-      const NodeType node_type = GetNodeType(node);
-      if (node_type == NodeType::kLeaf) {  // leaf node with a scalar output
-        CHECK(flag_leaf_vector != 1)
-          << "Inconsistent use of leaf vector: if one leaf node does not use"
-          << "a leaf vector, *no other* leaf node can use a leaf vector";
-        flag_leaf_vector = 0;  // now no leaf can use leaf vector
-
-        tree.SetLeaf(nid, static_cast<tl_float>(node.leaf_value()));
-      } else if (node_type == NodeType::kLeafVector) {
-        // leaf node with vector output
-        CHECK(flag_leaf_vector != 0)
-          << "Inconsistent use of leaf vector: if one leaf node uses "
-          << "a leaf vector, *every* leaf node must use a leaf vector as well";
-        flag_leaf_vector = 1;  // now every leaf must use leaf vector
-
-        const int len = node.leaf_vector_size();
-        CHECK_EQ(len, model.num_output_group)
-          << "The length of leaf vector must be identical to the "
-          << "number of output groups";
-        std::vector<tl_float> leaf_vector(len);
-        for (int k = 0; k < len; ++k) {
-          leaf_vector[k] = static_cast<tl_float>(node.leaf_vector(k));
-        }
-        tree.SetLeafVector(nid, leaf_vector);
-      } else if (node_type == NodeType::kNumericalSplit) {  // numerical split
-        const auto split_index = node.split_index();
-        const std::string& opname = node.op();
-        CHECK_LT(split_index, model.num_feature)
-          << "split_index must be between 0 and [num_feature] - 1.";
-        CHECK_GE(split_index, 0) << "split_index must be positive.";
-        CHECK_GT(optable.count(opname), 0) << "No operator `"
-                                           << opname << "\" exists";
-        tree.AddChilds(nid);
-        tree.SetNumericalSplit(nid,
-                               static_cast<unsigned>(split_index),
-                               static_cast<tl_float>(node.threshold()),
-                               node.default_left(),
-                               optable.at(opname));
-        Q.push({node.left_child(), tree.LeftChild(nid)});
-        Q.push({node.right_child(), tree.RightChild(nid)});
-      } else {  // categorical split
-        const auto split_index = node.split_index();
-        CHECK_LT(split_index, model.num_feature)
-          << "split_index must be between 0 and [num_feature] - 1.";
-        CHECK_GE(split_index, 0) << "split_index must be positive.";
-        const int left_categories_size = node.left_categories_size();
-        std::vector<uint32_t> left_categories;
-        for (int k = 0; k < left_categories_size; ++k) {
-          const auto cat = node.left_categories(k);
-          CHECK(cat <= std::numeric_limits<uint32_t>::max());
-          left_categories.push_back(static_cast<uint32_t>(cat));
-        }
-        tree.AddChilds(nid);
-        tree.SetCategoricalSplit(nid,
-                                 static_cast<unsigned>(split_index),
-                                 node.default_left(),
-                                 node.missing_category_to_zero(),
-                                 left_categories);
-        Q.push({node.left_child(), tree.LeftChild(nid)});
-        Q.push({node.right_child(), tree.RightChild(nid)});
-      }
-      /* set node statistics */
-      if (node.has_data_count()) {
-        tree.SetDataCount(nid, static_cast<size_t>(node.data_count()));
-      }
-      if (node.has_sum_hess()) {
-        tree.SetSumHess(nid, node.sum_hess());
-      }
-      if (node.has_gain()) {
-        tree.SetGain(nid, node.gain());
-      }
-    }
-  }
-  if (flag_leaf_vector == 0) {
-    if (model.num_output_group > 1) {
-      // multi-class classification with gradient boosted trees
-      CHECK(!model.random_forest_flag)
-        << "To use a random forest for multi-class classification, each leaf "
-        << "node must output a leaf vector specifying a probability "
-        << "distribution";
-      CHECK_EQ(ntree % model.num_output_group, 0)
-        << "For multi-class classifiers with gradient boosted trees, the number "
-        << "of trees must be evenly divisible by the number of output groups";
-    }
-  } else if (flag_leaf_vector == 1) {
-    // multiclass classification with a random forest
-    CHECK(model.random_forest_flag)
-      << "In multi-class classifiers with gradient boosted trees, each leaf "
-      << "node must output a single floating-point value.";
-  } else {
-    LOG(FATAL) << "Impossible thing happened: model has no leaf node!";
-  }
-  *out = std::move(model);
-}
-
-void ExportProtobufModel(const char* filename, const Model& model) {
-  GOOGLE_PROTOBUF_VERIFY_VERSION;
-
-  std::unique_ptr<dmlc::Stream> fi(dmlc::Stream::Create(filename, "w"));
-  dmlc::ostream os(fi.get());
-  treelite_protobuf::Model protomodel;
-
-  protomodel.set_num_feature(
-    static_cast<google::protobuf::int32>(model.num_feature));
-
-  protomodel.set_num_output_group(
-    static_cast<google::protobuf::int32>(model.num_output_group));
-
-  protomodel.set_random_forest_flag(model.random_forest_flag);
-
-  // extra parameters field
-  for (const auto& kv : model.param.__DICT__()) {
-    (*protomodel.mutable_extra_params())[kv.first] = kv.second;
-  }
-
-  // flag to check consistent use of leaf vector
-  // 0: no leaf should use leaf vector
-  // 1: every leaf should use leaf vector
-  // -1: indeterminate
-  int8_t flag_leaf_vector = -1;
-
-  const int ntree = model.trees.size();
-  for (int i = 0; i < ntree; ++i) {
-    const Tree& tree = model.trees[i];
-    treelite_protobuf::Tree* proto_tree = protomodel.add_trees();
-
-    std::queue<std::pair<int, treelite_protobuf::Node*>> Q;
-    Q.push({0, proto_tree->mutable_head()});
-    while (!Q.empty()) {
-      auto elem = Q.front(); Q.pop();
-      const int nid = elem.first;
-      treelite_protobuf::Node* proto_node = elem.second;
-      if (tree.IsLeaf(nid)) {  // leaf node
-        if (tree.HasLeafVector(nid)) {  // leaf node with vector output
-          CHECK(flag_leaf_vector != 0)
-            << "Inconsistent use of leaf vector: if one leaf node uses "
-            << "a leaf vector, *every* leaf node must use a leaf vector as well";
-          flag_leaf_vector = 1;  // now every leaf must use leaf vector
-
-          const auto& leaf_vector = tree.LeafVector(nid);
-          CHECK_EQ(leaf_vector.size(), model.num_output_group)
-            << "The length of leaf vector must be identical to the "
-            << "number of output groups";
-          for (tl_float e : leaf_vector) {
-            proto_node->add_leaf_vector(static_cast<float>(e));
-          }
-          CHECK_EQ(proto_node->leaf_vector_size(), leaf_vector.size());
-        } else {  // leaf node with scalar output
-          CHECK(flag_leaf_vector != 1)
-            << "Inconsistent use of leaf vector: if one leaf node does not use"
-            << "a leaf vector, *no other* leaf node can use a leaf vector";
-          flag_leaf_vector = 0;  // now no leaf can use leaf vector
-
-          proto_node->set_leaf_value(static_cast<float>(tree.LeafValue(nid)));
-        }
-      } else if (tree.SplitType(nid) == SplitFeatureType::kNumerical) {
-        // numerical split
-        const unsigned split_index = tree.SplitIndex(nid);
-        const tl_float threshold = tree.Threshold(nid);
-        const bool default_left = tree.DefaultLeft(nid);
-        const Operator op = tree.ComparisonOp(nid);
-
-        proto_node->set_default_left(default_left);
-        proto_node->set_split_index(static_cast<google::protobuf::int32>(split_index));
-        proto_node->set_split_type(treelite_protobuf::Node_SplitFeatureType_NUMERICAL);
-        proto_node->set_op(OpName(op));
-        proto_node->set_threshold(static_cast<float>(threshold));
-        Q.push({tree.LeftChild(nid), proto_node->mutable_left_child()});
-        Q.push({tree.RightChild(nid), proto_node->mutable_right_child()});
-      } else {  // categorical split
-        const unsigned split_index = tree.SplitIndex(nid);
-        const auto& left_categories = tree.LeftCategories(nid);
-        const bool default_left = tree.DefaultLeft(nid);
-        const bool missing_category_to_zero = tree.MissingCategoryToZero(nid);
-
-        proto_node->set_default_left(default_left);
-        proto_node->set_split_index(static_cast<google::protobuf::int32>(split_index));
-        proto_node->set_split_type(treelite_protobuf::Node_SplitFeatureType_CATEGORICAL);
-        proto_node->set_missing_category_to_zero(missing_category_to_zero);
-        for (auto e : left_categories) {
-          proto_node->add_left_categories(static_cast<google::protobuf::uint32>(e));
-        }
-        Q.push({tree.LeftChild(nid), proto_node->mutable_left_child()});
-        Q.push({tree.RightChild(nid), proto_node->mutable_right_child()});
-      }
-      /* set node statistics */
-      if (tree.HasDataCount(nid)) {
-        proto_node->set_data_count(
-          static_cast<google::protobuf::uint64>(tree.DataCount(nid)));
-      }
-      if (tree.HasSumHess(nid)) {
-        proto_node->set_sum_hess(tree.SumHess(nid));
-      }
-      if (tree.HasGain(nid)) {
-        proto_node->set_gain(tree.Gain(nid));
-      }
-    }
-  }
-  CHECK(protomodel.SerializeToOstream(&os))
-    << "Failed to write Protocol Buffers file";
-  os.set_stream(nullptr);
-}
-
-}  // namespace frontend
-}  // namespace treelite
-
-#else   // TREELITE_PROTOBUF_SUPPORT
-
-namespace treelite {
-namespace frontend {
-
-DMLC_REGISTRY_FILE_TAG(protobuf);
-
-void LoadProtobufModel(const char* filename, Model* out) {
-  LOG(FATAL) << "Treelite was not compiled with Protobuf!";
-}
-
-void ExportProtobufModel(const char* filename, const Model& model) {
-  LOG(FATAL) << "Treelite was not compiled with Protobuf!";
-}
-
-}  // namespace frontend
-}  // namespace treelite
-
-#endif  // TREELITE_PROTOBUF_SUPPORT
diff --git a/src/tree.proto b/src/tree.proto
deleted file mode 100644
index 86dd65b..0000000
--- a/src/tree.proto
+++ /dev/null
@@ -1,68 +0,0 @@
-syntax = "proto2";
-
-package treelite_protobuf;
-
-message Model {
-  repeated Tree trees = 1;
-  optional int32 num_feature = 2;
-  optional int32 num_output_group = 3;   // >1 for multi-class classification;
-                                         // =1 for everything else
-  optional bool random_forest_flag = 4;  // true for random forest
-                                         // false for gradient boosted trees
-  map<string, string> extra_params = 5;  // extra parameters
-}
-
-message Tree {
-  optional Node head = 1;
-}
-
-message Node {
-   optional Node left_child = 1;     // Left child; missing if leaf
-   optional Node right_child = 2;    // Right child; missing if leaf
-   optional bool default_left = 3;   // Default direction for missing values
-                                     // true: default to left
-                                     // false: default to right
-   optional int32 split_index = 4;   // Feature index used for the split;
-                                     // missing if leaf
-   enum SplitFeatureType {
-     NUMERICAL = 0;
-     CATEGORICAL = 1;
-   }
-   optional SplitFeatureType split_type = 5;
-                                     // Type of feature used for the split
-                                     // missing if leaf
-   optional string op = 6;           // Operation used for comparison (e.g. "<")
-                                     // of form [feature value] OP [threshold].
-                                     // The left child is taken if the
-                                     // expression evaluates to true; the right
-                                     // child is taken otherwise.
-                                     // missing if leaf or categorical split
-   optional float threshold = 7;     // Decision threshold
-                                     // missing if leaf or categorical split
-   repeated uint32 left_categories = 8;
-                                     // List of all categories belonging to
-                                     // the left child. All other categories
-                                     // will belong to the right child.
-                                     // missing if leaf or numerical split
-   optional float leaf_value = 9;    // Leaf value; missing if non-leaf
-                                     // also missing if leaf_vector field exists
-   repeated float leaf_vector = 10;  // Usually missing; only used for random
-                                     // forests with multi-class classification
-   optional uint64 data_count = 11;  // number of data points whose traversal
-                                     // paths include this node. May be
-                                     // ommitted if unavailable
-   optional double sum_hess = 12;    // sum of hessian values for all data
-                                     // points whose traversal paths include
-                                     // this node. This value is generally
-                                     // correlated positively with the data
-                                     // count. May be omitted if unavailable
-   optional double gain = 13;        // change in loss that is attributed to
-                                     // particular split; may be omitted if
-                                     // unavailable
-   optional bool missing_category_to_zero = 14;
-                                     // Whether to convert missing value to zero
-                                     // Only applicable when split_type is
-                                     // set to CATEGORICAL. When this flag is
-                                     // set, it overrides behavior of
-                                     // default_left
-}
diff --git a/tests/python/test_protobuf.py b/tests/python/test_protobuf.py
deleted file mode 100644
index 2d4f4d3..0000000
--- a/tests/python/test_protobuf.py
+++ /dev/null
@@ -1,28 +0,0 @@
-# -*- coding: utf-8 -*-
-"""Tests for reading/writing Protocol Buffers"""
-import os
-
-import pytest
-import treelite
-import treelite_runtime
-from treelite.contrib import _libext
-from .metadata import dataset_db
-from .util import os_compatible_toolchains, check_predictor
-
-
-@pytest.mark.parametrize('toolchain', os_compatible_toolchains())
-@pytest.mark.parametrize('quantize', [True, False])
-@pytest.mark.parametrize('dataset', ['mushroom', 'dermatology', 'toy_categorical'])
-def test_round_trip(tmpdir, dataset, quantize, toolchain):
-    """Perform round-trip tests"""
-    libpath = os.path.join(tmpdir, dataset_db[dataset].libname + _libext())
-    pb_path = os.path.join(tmpdir, 'my.buffer')
-    model = treelite.Model.load(dataset_db[dataset].model, model_format=dataset_db[dataset].format)
-
-    model.export_protobuf(pb_path)
-    model2 = treelite.Model.load(pb_path, model_format='protobuf')
-
-    params = {'quantize': (1 if quantize else 0), 'parallel_comp': model.num_tree}
-    model2.export_lib(toolchain=toolchain, libpath=libpath, params=params, verbose=True)
-    predictor = treelite_runtime.Predictor(libpath=libpath, verbose=True)
-    check_predictor(predictor, dataset)
